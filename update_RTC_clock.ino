// update_RTC_clock if desired.


void   printDateToSerial() {
  // get the current date / time from the RTC
  Time t = rtc.time();

  char buf[50];
  String dAsStr;  
  // Format and Show time and date on Serial monitor
  dAsStr = dayAsString(t.day);
  snprintf(buf, sizeof(buf), "%d %-12s %04d-%02d-%02d %02d:%02d:%02d",
           t.day,                       // show day number as presented by ds1302 
           dAsStr.c_str(),              // convert from String so snprintf can handle it.
           t.yr, t.mon, t.date,         // strange to call the day-of-the-month "date" Well it's documented like that..
           t.hr, t.min, t.sec);
  Serial.println(buf);
}



void   printCompileDateToSerial() {
    
/* part of
 *  https://markmail.org/message/5e7nvpwbitybde4r
 *  
 *  __DATE__ The date of translation of the source file (a character string
 *           literal of the form "Mmm dd yyyy", where the names of the months
 *           are the same as those generated by the asctime function, and the
 *           first character of dd is a space character if the value is less
 *           than 10).  If the date of translation is not available, an
 *           implementation-defined valid date shall be supplied. 
 *  
 *  
 *  __TIME__ The time of translation of the source file (a character string
 *           literal of the form "hh:mm:ss" as in the time generated by the
 *           asctime function).  If the time of translation is not available,
 *           an implementation-defined valid time shall be supplied. 
 */
  
  Serial.print(__DATE__);
  Serial.print("    at ");
  Serial.println(__TIME__);
}

void leading2zeroes(byte toprint) {
    if (toprint < 10) {Serial.print("0");}
    Serial.print(toprint);
}


void leading4zeroes(unsigned short toprint) {
    if      (toprint <   10) {Serial.print("200");}
    else if (toprint <  100) {Serial.print("20"); }
    else if (toprint < 1000) {Serial.print("2");  }
    Serial.print(toprint);
}


// Ask the date + time values to set the clock - Still needs validation!
bool getDateTimeInput() {
  Serial.print("Please enter the current year, 2000-2099 ONLY the last two digits. - ");
  year = 2000 + read2num(); // Need to reprogram in century changes OR make a read4num function 
  Serial.println(year);
  Serial.print("Please enter the current month, 1-12. - ");
  month = read2num();
  Serial.println(months[month-1]);
  Serial.print("Please enter the current day of the month, 1-31. - ");
  monthday = read2num();
  Serial.println(monthday);
  Serial.println("Please enter the current day of the week, 1-7.");
  Serial.print("1 Sun | 2 Mon | 3 Tues | 4 Weds | 5 Thu | 6 Fri | 7 Sat - ");
  weekday = read2num();
  Serial.println(dayAsString(weekday));
  Serial.print("Please enter the current hour in 24hr format, 0-23. - ");
  hour = read2num();
  Serial.println(hour);
  Serial.print("Please enter the NEXT minute, 0-59. - ");
  minute = read2num();
  Serial.println(minute);
  second = 0;
  Serial.println("The data has been entered.");
    
  Serial.print("\nDate: "); leading4zeroes(year); 
  Serial.print("-"); leading2zeroes(month); 
  Serial.print("-"); leading2zeroes(monthday);

  Serial.print(" Time: "); leading2zeroes(hour); Serial.print(":"); 
  leading2zeroes(minute);  Serial.print(":"); leading2zeroes(second);
  Serial.print("\nDay of week: ");
  Serial.println(dayAsString(weekday));

  
  Serial.println("\nIs this the correct date time to be set into the real time clock? ");
  Serial.println("Reply 'N' or 'n' if not. Try again.\n");
  Serial.println("Or wait for the time to be exact and then reply 'Y' 'y'");

  bool allowSetClock = false;
  bool correctYNanswer = false;
  while (! correctYNanswer ) {
      while (!Serial.available()) delay(10);  // wait for input
      byte incomingbyte = Serial.read();
      incomingbyte = incomingbyte & ~(0x20); // set bit to change letter to UPPERCASE
      // Serial.print("Incoming char: '"); Serial.write(incomingbyte); Serial.println("'");

      if (incomingbyte == 'Y') {
        Serial.println("Allowing RTC to be set with the values above");
        allowSetClock = true;
        correctYNanswer = true;     // correct answer "Y" or "y"
      } else {
        if (incomingbyte == 'N') {
            correctYNanswer = true; // correct answer "N" or "n"
        } else {
            Serial.println("Reply is not 'Y' nor 'N'; Try again ");
            correctYNanswer = false;
        }
      }
  }
  return allowSetClock;   
}


byte read2num() { // accept max two numeric characters and return the values as two nibbles
  while (!Serial.available()) delay(10); // wait for Serial input to come available
  
  byte intermediate = 0;
  
  bool gotOKvalue = false;
  while (! gotOKvalue) {
      byte usedBytes = 0;
      while (!Serial.available()) delay(10); // wait for Serial input to come available
      byte incomingByte = Serial.read();
      while (incomingByte != '\n') {
        Serial.print("Got byte: "); Serial.print(incomingByte,DEC); 
        Serial.print(" '"); Serial.write(incomingByte); Serial.println("' ");
        if (incomingByte >= '0' && incomingByte <= '9') {
            intermediate = intermediate * 10 + (incomingByte - '0');
            usedBytes++;
            if (usedBytes > 2) {
                Serial.print("More than 2 digits; ignoring: '");
                Serial.print(intermediate);
                Serial.println("' Retry and enter valid data");
                intermediate = 0;
                gotOKvalue = false;
                usedBytes = 0;
                
                while (incomingByte != '\n') {             // skip input until we get a newline character
                    while (!Serial.available()) delay(10); // wait for Serial input to come available
                    incomingByte = Serial.read();          // read next byte
                    Serial.print("Skip byte: "); Serial.print(incomingByte,DEC); 
                    Serial.print(" '"); Serial.write(incomingByte); Serial.println("' ");
                }
                delay(250);
            }
            while (!Serial.available()) delay(10);  // wait for Serial input to come available
            incomingByte = Serial.read();           // read next byte
        } else {
            Serial.println("Ignoring non numeric invalid input byte, try again");
            intermediate = 0;
            gotOKvalue = false;
            usedBytes = 0;
            while (!Serial.available()) delay(10);  // wait for Serial input to come available
            incomingByte = Serial.read();           // read next byte
            delay(1000);
        }
      }

      if ((usedBytes > 0) && (usedBytes <= 2)) {    // max 2 bytes to be used
          gotOKvalue = true;
      } else {
          gotOKvalue = false;
          while (incomingByte != '\n') {            // skip until we get a newline character
            while (!Serial.available()) delay(10);  // wait for Serial input to come available
            incomingByte = Serial.read();           // read next byte
            Serial.print("Ignoring byte: "); Serial.print(incomingByte,DEC); 
            Serial.print(" '"); Serial.write(incomingByte); Serial.println("' ");
          }
          delay(1000);
      }
  }
  
  Serial.flush();
  Serial.print(" Return: "); Serial.println(intermediate);
  return intermediate;
}


byte readByte() {
  // accept max two numeric characters
  // and add their values
  // and return that value as a byte
  
  byte intermediate = 0;
  while (!Serial.available()) delay(10);            // wait for Serial input to come available
  byte incomingByte = Serial.read();                // read next byte
  
  bool gotOKvalue = false;
  while (! gotOKvalue) {
      byte usedBytes = 0;
      while (incomingByte != '\n') {
        Serial.print("Got byte: "); Serial.print(incomingByte,DEC); 
        Serial.print(" '"); Serial.write(incomingByte); Serial.println("' ");
        if (incomingByte >= '0' && incomingByte <= '9') {
            intermediate = intermediate * 10 + (incomingByte - '0');
            usedBytes++;
            while (!Serial.available()) delay(10);  // wait for Serial input to come available
            incomingByte = Serial.read();           // read next byte
        } else {
            Serial.println("Ignoring non numeric invalid input byte, try again");
            intermediate = 0;
            gotOKvalue = false;
            usedBytes = 0;
            while (!Serial.available()) delay(10);  // wait for Serial input to come available
            incomingByte = Serial.read();           // read next byte
        }
      }

      if ((usedBytes > 0) && (usedBytes <= 2)) {    // max 2 bytes to be used
          gotOKvalue = true;
      } else {
          gotOKvalue = false;
          intermediate = 0;
          usedBytes = 0;
          while (!Serial.available()) delay(10);    // wait for Serial input to come available
          incomingByte = Serial.read();             // read next byte
      }
      Serial.print("gotOKvalue="); Serial.println(gotOKvalue);      
  }
  
  Serial.flush();
  Serial.print(" Return: "); Serial.println(intermediate);
  return intermediate;
}


bool SetClockValues() {
   uint32_t Timeout_msec = 25000;

  /* ask to SET date+time to the RTC */
  Serial.print("The current date and time is: ");
  printDateToSerial();
  Serial.print("This sketch compile date and time is: ");
  printCompileDateToSerial();

  Serial.println("\nPlease verify 'newline' ending in the Serial Monitor.");
  Serial.println("Would you like to set the date and time now? Yy/Nn");
  Serial.print("\nThe Arduino will wait ");
  Serial.print(Timeout_msec / 1000);
  Serial.println(" seconds before skipping the RTC set.");
  unsigned long timeoutstart = millis();
  while (!Serial.available() && ((millis() - timeoutstart) < Timeout_msec )) delay(10);  // wait for input
  if ((millis() - timeoutstart) >= Timeout_msec ) {
    // assume no serial monitor attached
    allowToSetClock = false; // skip setting the clock
    tft.setCursor(0,180);
    tft.println((" TIME-out;"));
    tft.println((" Skipping SET CLOCK"));
    delay(500);
    return true;
  }
  byte incomingbyte = Serial.read();
  incomingbyte = incomingbyte & ~(0x20); // set bit to change letter to UPPERCASE
  // Serial.print("DEBUG Incoming char: '"); Serial.write(incomingbyte); Serial.println("'");
  
  if (incomingbyte == 'Y') {
    Serial.println("Allowing RTC to be set");
    // This allows the user to change the date and time in the RTC clock

    while (! getDateTimeInput()); // keep asking date/time values until they are valid.
    Serial.print("\nThe current date and time is now: ");
    printDateToSerial();
    allowToSetClock = true;
  } else {
    if (incomingbyte == 'N') {
        return true; // mark time setting ready
    } else {
        Serial.println("Reply is not 'Y' 'y' 'N' nor 'n'; Try again ");
        return false; // mark time setting NOT ready
    }
  }
  Serial.println("\nThank you.\n");
  return true; // mark time setting ready
}

void setClock() {
  // Initialize the chip: turn off write protection and clear the clock halt flag. 
  // This is only needed to SET / change date + time. 
  // See the DS1302 datasheet for details.
  
  rtc.writeProtect(false);
  rtc.halt(false);

  // Create a new time object to set the date + time.
  // An example:
  // Sunday, 22 September 2019 at 10:38:50.
  // Time t(2019, 9, 22, 10, 38, 50, Time::kSunday);

  // ====================================================================================
  Time t(year, month, monthday, hour, minute, second, weekday);
  // ====================================================================================

  // Write the time and date onto the RTC chip.
  rtc.time(t);
} // END of setClock()
